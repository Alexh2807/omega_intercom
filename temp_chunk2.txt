        final data = Uint8List.fromList(chunk); // duplique le buffer

        if (_mode == ConnectionMode.lan) {
          final peers = _lanPeers.values.toList(growable: false);
          for (final p in peers) {
            _audioSock?.send(data, p.address, p.port);
          }
        } else {
          final dst = _serverAddress;
          if (dst != null) _audioSock?.send(data, dst, _serverPort);
        }
      } catch (e) {
        _log('Erreur envoi UDP: $e');
      }
    });

    _log('Capture micro démarrée → ${_mode == ConnectionMode.lan ? 'LAN' : 'Internet'}');
  }

  Future<void> stopTalking() async {
    await _micSub?.cancel();
    _micSub = null;
    if (await _recorder.isRecording()) {
      await _recorder.stop();
    }
    _log('Capture micro arrêtée');
  }

  Future<void> stop() async {
    await stopTalking();

    _helloTimer?.cancel();
    _helloTimer = null;

    _discoverySock?.close();
    _discoverySock = null;

    // Stop lecteur natif
    await _native.stop();

    _audioSock?.close();
    _audioSock = null;

    _initialized = false;
    _lanPeers.clear();
    _lanLastSeen.clear();
    _emitPeers();

    _log('Intercom arrêté');
  }

  void dispose() {
    _logC.close();
    _peersC.close();
  }

  // ========= UDP : réception audio =========
  DateTime _lastRxLog = DateTime.fromMillisecondsSinceEpoch(0);

  void _onAudioUdp(RawSocketEvent ev) {
    if (ev != RawSocketEvent.read) return;
    final dg = _audioSock?.receive();
    if (dg == null) return;

    // On pousse les octets PCM16 directement dans AudioTrack natif
    _native.write(dg.data);

    // Logs
    final now = DateTime.now();
    if (now.difference(_lastRxLog).inMilliseconds > 500) {
      _lastRxLog = now;
      _log('RX ${dg.data.length} bytes de ${dg.address.address}:${dg.port}');
    }

    // MAJ "vu"
    if (_mode == ConnectionMode.lan) {
      final ip = dg.address.address;
      if (!_lanPeers.containsKey(ip)) {
        _lanPeers[ip] = PeerInfo(
          name: 'Appareil',
          address: dg.address,
          port: dg.port,
          isServer: false,
        );
        _emitPeers();
      }
      _lanLastSeen[ip] = DateTime.now();
    }
  }

  // ========= UDP : découverte LAN =========
  void _onDiscoveryUdp(RawSocketEvent ev) {
    if (ev != RawSocketEvent.read) return;
    final dg = _discoverySock?.receive();
    if (dg == null) return;

    try {
      final txt = utf8.decode(dg.data);
      final parts = txt.split('|');
      if (parts.length < 4) return;

      final cmd = parts[0];
      final peerId = parts[1];
      if (peerId == _selfId) return;

      final peerPort = int.tryParse(parts[2]) ?? _lanAudioPort;
      final peerName = parts.sublist(3).join('|');
      final ip = dg.address.address;

      _lanPeers[ip] = PeerInfo(
        name: (peerName.isEmpty ? 'Appareil' : peerName),
        address: dg.address,
        port: peerPort,
        isServer: false,
      );
      _lanLastSeen[ip] = DateTime.now();
      _emitPeers();

      if (cmd == 'HELLO') {
        final reply = 'HERE|$_selfId|$_lanAudioPort|Appareil';
        _discoverySock?.send(utf8.encode(reply), dg.address, _lanDiscoveryPort);
      }
    } catch (_) {/* ignore */}
  }

  void _sendHello() {
    if (_discoverySock == null) return;
    final msg = 'HELLO|$_selfId|$_lanAudioPort|Appareil';
    final bytes = utf8.encode(msg);
    final bcast = InternetAddress('255.255.255.255');
    _discoverySock!.send(bytes, bcast, _lanDiscoveryPort);

    for (final p in _lanPeers.values) {
      _discoverySock!.send(
        utf8.encode('HERE|$_selfId|$_lanAudioPort|Appareil'),
        p.address,
        _lanDiscoveryPort,
      );
    }
  }

  void _purgeOldPeers() {
    final now = DateTime.now();
    final toRemove = <String>[];
    _lanLastSeen.forEach((ip, ts) {
      if (now.difference(ts) > const Duration(seconds: 6)) {
        toRemove.add(ip);
      }
    });
    for (final ip in toRemove) {
      _lanLastSeen.remove(ip);
      _lanPeers.remove(ip);
    }
    if (toRemove.isNotEmpty) _emitPeers();
  }

  // ========= Internet (DNS) =========
  Future<void> _resolveServerIfNeeded() async {
    if (_serverAddress != null || _serverHost == null || _serverHost!.isEmpty) {
      _emitPeers();
      return;
    }
    final parsed = InternetAddress.tryParse(_serverHost!);
    if (parsed != null) {
      _serverAddress = parsed;
      _emitPeers();
      return;
    }
    try {
      final list = await InternetAddress.lookup(_serverHost!);
      _serverAddress = list.firstWhere(
            (a) => a.type == InternetAddressType.IPv4,
        orElse: () => list.first,
      );
      _emitPeers();
    } catch (_) {
      _emitPeers();
    }
  }

  void _emitPeers() {
    if (_mode == ConnectionMode.internet) {
      final resolved =
          _serverAddress ?? InternetAddress.tryParse(_serverHost ?? '');
      _peersC.add([
        PeerInfo(
          name: 'Serveur',
          address: resolved ?? InternetAddress.anyIPv4,
          port: _serverPort,
          isServer: true,
        )
      ]);
    } else {
      _peersC.add(_lanPeers.values.toList(growable: false));
    }
  }
}
