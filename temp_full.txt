// lib/intercom_service.dart
import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'dart:math';
import 'dart:typed_data';

import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:record/record.dart';

enum ConnectionMode { lan, internet }

class PeerInfo {
  final String id;
  final String name;
  final InternetAddress address;
  final int port;
  final bool isServer;
  const PeerInfo({
    required this.id,
    required this.name,
    required this.address,
    required this.port,
    this.isServer = false,
  });
}

// --- Lecteur natif Android via MethodChannel ---
class _NativePlayer {
  static const MethodChannel _ch = MethodChannel('intercom_native_audio');

  Future<void> start({int sampleRate = 16000}) async {
    try {
      await _ch.invokeMethod('start', {'sr': sampleRate});
    } catch (e) {
      debugPrint('Native start error: $e');
    }
  }

  Future<void> write(Uint8List data) async {
    try {
      // On passe directement le ByteArray au côté Kotlin
      await _ch.invokeMethod('write', data);
    } catch (e) {
      debugPrint('Native write error: $e');
    }
  }

  Future<void> stop() async {
    try {
      await _ch.invokeMethod('stop');
    } catch (e) {
      debugPrint('Native stop error: $e');
    }
  }

  void _sendPresence() {
    if (_mode != ConnectionMode.internet) return;
    final dst = _serverAddress;
    if (dst == null) return;
    final msg = 'ICSV1|PRES|$_selfId|$_displayName';
    _audioSock?.send(utf8.encode(msg), dst, _serverPort);
  }

  Uint8List _applyGainPcm16(Uint8List pcm, double gain) {
    try {
      final bd = ByteData.view(pcm.buffer, pcm.offsetInBytes, pcm.lengthInBytes);
      for (int i = 0; i < pcm.lengthInBytes; i += 2) {
        int s = bd.getInt16(i, Endian.little);
        double v = s * gain;
        if (v > 32767) v = 32767;
        if (v < -32768) v = -32768;
        bd.setInt16(i, v.toInt(), Endian.little);
      }
      return pcm;
    } catch (_) {
      return pcm;
    }
  }
}

class IntercomService {
  // PCM16 mono @ 16 kHz : simple, fiable
  static const int _sampleRate = 16000;

  // Ports
  static const int _lanAudioPort = 50005;     // audio PCM LAN
  static const int _lanDiscoveryPort = 50004; // découverte LAN
  static const int _defaultInternetPort = 55667;

  // Réseau / Audio
  RawDatagramSocket? _audioSock;
  RawDatagramSocket? _discoverySock;
  final AudioRecorder _recorder = AudioRecorder();
  StreamSubscription<Uint8List>? _micSub;

  final _native = _NativePlayer();

  bool _initialized = false;

  // Mode
  ConnectionMode _mode = ConnectionMode.lan;

  // Internet
  String? _serverHost;
  int _serverPort = _defaultInternetPort;
  InternetAddress? _serverAddress;
  int _internetPeerCount = 0; // nombre total de clients (y compris soi)
  final Map<String, PeerInfo> _netPeers = {}; // id -> PeerInfo (Internet)
  Timer? _presenceTimer; // présence périodique Internet
  String _displayName = 'Appareil';

  // Réglages audio par participant (id)
  final Set<String> _muted = <String>{};
  final Map<String, double> _gain = <String, double>{};
  void setMuted(String peerId, bool m) { if (m) { _muted.add(peerId); } else { _muted.remove(peerId); } }
  void setGain(String peerId, double g) { _gain[peerId] = g.clamp(0.0, 2.0); }
  bool isMuted(String peerId) => _muted.contains(peerId);
  double gainOf(String peerId) => _gain[peerId] ?? 1.0;

  // Découverte LAN
  String _selfId =
      '${DateTime.now().microsecondsSinceEpoch.toRadixString(16)}-${Random().nextInt(0xFFFF).toRadixString(16)}';
  final Map<String, PeerInfo> _lanPeers = {};    // ip -> PeerInfo
  final Map<String, DateTime> _lanLastSeen = {}; // ip -> lastSeen
  Timer? _helloTimer;

  // Flux UI
  final _logC = StreamController<String>.broadcast();
  final _peersC = StreamController<List<PeerInfo>>.broadcast();
  Stream<String> get logStream => _logC.stream;
  Stream<List<PeerInfo>> get peersStream => _peersC.stream;
  void _log(String m) { if (kDebugMode) print('[Intercom] $m'); _logC.add(m); }

  // ========= API UI =========

  Future<bool> requestPermissions() async {
    final mic = await Permission.microphone.request();
    final ok = mic.isGranted;
    if (!ok) _log('Permission micro refusée');
    return ok;
  }

  void setMode(ConnectionMode mode) {
    _mode = mode;
    _log('Mode sélectionné: ${_mode.name}');
    _emitPeers();
  }

  void setInternetEndpoint({required String host, int? port}) {
    _serverHost = host.trim();
    if (port != null) _serverPort = port;
    _serverAddress = null;
    _log('Endpoint Internet: $_serverHost:$_serverPort');
    _emitPeers();
  }

  void setPeer(String ip) {
    final addr = InternetAddress(ip.trim());
    _lanPeers[addr.address] = PeerInfo(
      id: 'manual',
      name: 'Appareil',
      address: addr,
      port: _lanAudioPort,
      isServer: false,
    );
    _lanLastSeen[addr.address] = DateTime.now();
    _emitPeers();
  }

  Future<void> start() async {
    if (_initialized) { _log('Déjà initialisé'); return; }

    // Socket audio (réception)
    _audioSock = await RawDatagramSocket.bind(
      InternetAddress.anyIPv4,
      _lanAudioPort,
      reuseAddress: true,
      reusePort: true,
    );
    _audioSock!.readEventsEnabled = true;
    _audioSock!.listen(_onAudioUdp);
    _log('Audio UDP: écoute sur 0.0.0.0:$_lanAudioPort');

    // Démarre le lecteur natif (AudioTrack)
    await _native.start(sampleRate: _sampleRate);

    // Découverte LAN
    _discoverySock = await RawDatagramSocket.bind(
      InternetAddress.anyIPv4,
      _lanDiscoveryPort,
      reuseAddress: true,
      reusePort: true,
    );
    _discoverySock!.broadcastEnabled = true;
    _discoverySock!.readEventsEnabled = true;
    _discoverySock!.listen(_onDiscoveryUdp);
    _log('Découverte UDP: écoute sur 0.0.0.0:$_lanDiscoveryPort');

    // Pings périodiques + purge
    _helloTimer?.cancel();
    _helloTimer = Timer.periodic(const Duration(seconds: 2), (_) {
      _sendHello();
      _purgeOldPeers();
    });
    _sendHello();

    _initialized = true;

    // Démarre présence Internet si nécessaire
    if (_mode == ConnectionMode.internet) {
      _presenceTimer?.cancel();
      _presenceTimer = Timer.periodic(const Duration(seconds: 3), (_) => _sendPresence());
      _sendPresence();
    }
  }

  Future<void> startTalking() async {
    if (!await requestPermissions()) {
      throw Exception('Permission micro refusée');
    }
    if (!_initialized) await start();

    if (_mode == ConnectionMode.internet) {
      await _resolveServerIfNeeded();
      if (_serverAddress == null) {
        _log('Impossible de résoudre $_serverHost');
        throw Exception('Serveur non résolu');
      }
    }

    // Micro « magnétophone » : PCM16 mono 16 kHz
    final stream = await _recorder.startStream(
      RecordConfig(
        encoder: AudioEncoder.pcm16bits,
        sampleRate: _sampleRate,
        numChannels: 1,
      ),
    );

    _micSub?.cancel();
    _micSub = stream.listen((Uint8List chunk) {
      try {
        if (chunk.isEmpty) return;
        // Prépare paquet avec en-tête mix-minus: 'IC' + version(1) + idLen(1) + selfId + PCM
        final idBytes = utf8.encode(_selfId);
        final headerLen = 4 + idBytes.length;
        final data = Uint8List(headerLen + chunk.length);
        final b = data.buffer.asUint8List();
        // Magic 'I','C'
        b[0] = 0x49; b[1] = 0x43; b[2] = 0x01; // version 1
        b[3] = idBytes.length & 0xFF;
        // id
        b.setRange(4, 4 + idBytes.length, idBytes);
        // payload PCM16
        b.setRange(4 + idBytes.length, data.length, chunk);

        if (_mode == ConnectionMode.lan) {
          final peers = _lanPeers.values.toList(growable: false);
          for (final p in peers) {
            _audioSock?.send(data, p.address, p.port);
          }
        } else {
          final dst = _serverAddress;
          if (dst != null) _audioSock?.send(data, dst, _serverPort);
        }
      } catch (e) {
        _log('Erreur envoi UDP: $e');
      }
    });

    _log('Capture micro démarrée → ${_mode == ConnectionMode.lan ? 'LAN' : 'Internet'}');
  }

  Future<void> stopTalking() async {
    await _micSub?.cancel();
    _micSub = null;
    if (await _recorder.isRecording()) {
      await _recorder.stop();
    }
    _log('Capture micro arrêtée');
  }

  Future<void> stop() async {
    await stopTalking();

    _helloTimer?.cancel();
    _helloTimer = null;

    _discoverySock?.close();
    _discoverySock = null;

    // Stop lecteur natif
    await _native.stop();

    _audioSock?.close();
    _audioSock = null;

    _presenceTimer?.cancel();
    _presenceTimer = null;

    _initialized = false;
    _lanPeers.clear();
    _lanLastSeen.clear();
    _emitPeers();

    _log('Intercom arrêté');
  }

  void dispose() {
    _logC.close();
    _peersC.close();
  }

  // ========= UDP : réception audio =========
  DateTime _lastRxLog = DateTime.fromMillisecondsSinceEpoch(0);

  void _onAudioUdp(RawSocketEvent ev) {
    if (ev != RawSocketEvent.read) return;
    final dg = _audioSock?.receive();
    if (dg == null) return;

    final bytes = dg.data;

    // Messages de contrôle serveur ? "ICSV1|PEERS|<n>"
    try {
      if (bytes.length >= 6 &&
          bytes[0] == 0x49 && bytes[1] == 0x43 && // 'I','C'
          bytes[2] == 0x53 && bytes[3] == 0x56 && bytes[4] == 0x31 && bytes[5] == 0x7C) { // 'S','V','1','|'
        // Décodage texte sécurisé
        final txt = utf8.decode(bytes, allowMalformed: true);
        final parts = txt.split('|');
        if (parts.length >= 3 && parts[1] == 'PEERS') {
          final n = int.tryParse(parts[2]) ?? 0;
          if (n != _internetPeerCount) {
            _internetPeerCount = n.clamp(0, 9999);
            _emitPeers();
          }
        }
        return; // paquet de contrôle consommé
      }
    } catch (_) {/* ignore */}

    // Contrôles additionnels (présence Internet)
    try {
      if (bytes.length >= 6 && bytes[0] == 0x49 && bytes[1] == 0x43) {
        final txt = utf8.decode(bytes, allowMalformed: true);
        if (txt.startsWith('ICSV1|PRES|')) {
          final parts = txt.split('|');
          if (parts.length >= 4) {
            final id = parts[2];
            final name = parts.sublist(3).join('|');
            if (id != _selfId) {
              _netPeers[id] = PeerInfo(
                id: id,
                name: name.isEmpty ? 'Utilisateur' : name,
                address: _serverAddress ?? InternetAddress.anyIPv4,
                port: _serverPort,
                isServer: false,
              );
              _emitPeers();
            }
          }
          return;
        }
        if (txt.startsWith('ICSV1|GONE|')) {
          final parts = txt.split('|');
          if (parts.length >= 3) {
            _netPeers.remove(parts[2]);
            _emitPeers();
          }
          return;
        }
      }
    } catch (_) {/* ignore */}

    // Parse en-tête audio mix-minus si présent: 'IC' 0x01 idLen id payload
    Uint8List payload;
    try {
      if (bytes.length >= 4 && bytes[0] == 0x49 && bytes[1] == 0x43 && bytes[2] == 0x01) {
        final idLen = bytes[3] & 0xFF;
        if (bytes.length >= 4 + idLen) {
          final senderId = utf8.decode(bytes.sublist(4, 4 + idLen));
          if (senderId == _selfId) {
            // C'est notre propre flux → ignorer (mix-minus)
            return;
          }
          payload = bytes.sublist(4 + idLen);
        } else {
          // En-tête corrompu → traiter comme brut
          payload = bytes;
        }
      } else {
        // Ancien format (pas d'en-tête)
        payload = bytes;
      }
    } catch (_) {
      payload = bytes;
    }

    // On pousse le PCM16 dans le lecteur natif
    if (payload.isNotEmpty) {
      Uint8List toPlay = payload;
      try {
        if (bytes.length >= 4 && bytes[0] == 0x49 && bytes[1] == 0x43 && bytes[2] == 0x01) {
          final idLen = bytes[3] & 0xFF;
          if (bytes.length >= 4 + idLen) {
            final sid = utf8.decode(bytes.sublist(4, 4 + idLen), allowMalformed: true);
            if (_muted.contains(sid)) return; // muet
            final g = _gain[sid] ?? 1.0;
            if (g != 1.0) toPlay = _applyGainPcm16(payload, g);
            if (_mode == ConnectionMode.internet && !_netPeers.containsKey(sid)) {
              _netPeers[sid] = PeerInfo(
                id: sid,
                name: 'Utilisateur',
                address: _serverAddress ?? InternetAddress.anyIPv4,
                port: _serverPort,
                isServer: false,
              );
              _emitPeers();
            }
          }
        }
      } catch (_) {/* ignore */}
      _native.write(toPlay);
    }

    // Logs
    final now = DateTime.now();
    if (now.difference(_lastRxLog).inMilliseconds > 500) {
      _lastRxLog = now;
      _log('RX ${dg.data.length} bytes de ${dg.address.address}:${dg.port}');
    }

    // MAJ "vu"
    if (_mode == ConnectionMode.lan) {
      final ip = dg.address.address;
      if (!_lanPeers.containsKey(ip)) {
        _lanPeers[ip] = PeerInfo(
          id: 'unknown',
          name: 'Appareil',
          address: dg.address,
          port: dg.port,
          isServer: false,
        );
        _emitPeers();
      }
      _lanLastSeen[ip] = DateTime.now();
    }
  }

  // ========= UDP : découverte LAN =========
  void _onDiscoveryUdp(RawSocketEvent ev) {
    if (ev != RawSocketEvent.read) return;
    final dg = _discoverySock?.receive();
    if (dg == null) return;

    try {
      final txt = utf8.decode(dg.data);
      final parts = txt.split('|');
      if (parts.length < 4) return;

      final cmd = parts[0];
      final peerId = parts[1];
      if (peerId == _selfId) return;

      final peerPort = int.tryParse(parts[2]) ?? _lanAudioPort;
      final peerName = parts.sublist(3).join('|');
      final ip = dg.address.address;

      _lanPeers[ip] = PeerInfo(
        id: peerId,
        name: (peerName.isEmpty ? 'Appareil' : peerName),
        address: dg.address,
        port: peerPort,
        isServer: false,
      );
      _lanLastSeen[ip] = DateTime.now();
      _emitPeers();

      if (cmd == 'HELLO') {
        final reply = 'HERE|$_selfId|$_lanAudioPort|Appareil';
        _discoverySock?.send(utf8.encode(reply), dg.address, _lanDiscoveryPort);
      }
    } catch (_) {/* ignore */}
  }

  void _sendHello() {
    if (_discoverySock == null) return;
    final msg = 'HELLO|$_selfId|$_lanAudioPort|Appareil';
    final bytes = utf8.encode(msg);
    final bcast = InternetAddress('255.255.255.255');
    _discoverySock!.send(bytes, bcast, _lanDiscoveryPort);

    for (final p in _lanPeers.values) {
      _discoverySock!.send(
        utf8.encode('HERE|$_selfId|$_lanAudioPort|Appareil'),
        p.address,
        _lanDiscoveryPort,
      );
    }
  }

  void _purgeOldPeers() {
    final now = DateTime.now();
    final toRemove = <String>[];
    _lanLastSeen.forEach((ip, ts) {
      if (now.difference(ts) > const Duration(seconds: 6)) {
        toRemove.add(ip);
      }
    });
    for (final ip in toRemove) {
      _lanLastSeen.remove(ip);
      _lanPeers.remove(ip);
    }
    if (toRemove.isNotEmpty) _emitPeers();
  }

  // ========= Internet (DNS) =========
  Future<void> _resolveServerIfNeeded() async {
    if (_serverAddress != null || _serverHost == null || _serverHost!.isEmpty) {
      _emitPeers();
      return;
    }
    final parsed = InternetAddress.tryParse(_serverHost!);
    if (parsed != null) {
      _serverAddress = parsed;
      _emitPeers();
      return;
    }
    try {
      final list = await InternetAddress.lookup(_serverHost!);
      _serverAddress = list.firstWhere(
            (a) => a.type == InternetAddressType.IPv4,
        orElse: () => list.first,
      );
      _emitPeers();
    } catch (_) {
      _emitPeers();
    }
  }

  void _emitPeers() {
    if (_mode == ConnectionMode.internet) {
      // Publie une liste factice représentant les pairs distants (n-1 car on s'inclut dans _internetPeerCount)
      final countOthers = (_internetPeerCount - 1).clamp(0, 9999);
      final list = List<PeerInfo>.generate(countOthers, (i) => PeerInfo(
        id: 'remote${i+1}',
        name: 'Participant ${i + 1}',
        address: _serverAddress ?? InternetAddress.anyIPv4,
        port: _serverPort,
        isServer: false,
      ));
      _peersC.add(list);
    } else {
      _peersC.add(_lanPeers.values.toList(growable: false));
    }
  }
}
